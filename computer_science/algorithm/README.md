알고리즘 관련 지식을 정리합니다


###### 관련도서 
- 누워서 읽는 알고리즘, 임백준, 한빛미디어
- [알고리즘 도감](http://www.yes24.com/Product/Goods/58290453), 이시다 모리테루/미야자키 쇼이치, 제이펍


# 알고리즘 이모저모
- 코딩 이전에 배워야 할, 기본이 되는 지식/ 알고리즘을 잘 이해하고 있다면 어떤 언어를 사용하든 금방 원하는 기능을 구현할 수 있게 된다.
- 상황에 따른 최적의 알고리즘(실행 시간/메모리 소비량 등을 고려)과 데이터 구조를 선택할 수 있는 능력
- Further studies: 효율이 좋은 알고리즘을 찾지 못하는 문제, 알고리즘으로 해결할 수 없는 문제

# 데이터 구조

데이터를 메모리에 저장할 때의 순서나 위치 관계. Index순? 가나다순? 

- [ ]  리스트
    - Linked list in C (다음 데이터의 메모리 위치를 가리키는 pointer) —> 이것 python으로 구현해봐야겠다.
    - 일반적으로 sparse한 특성, search/ add/ delete 등 기능 구현, circular list/ bidirectional list 등 소개
- [ ]  배열
    - Python list에 index 개념을 추가하면, C의 그것과 엇비슷한 설명 가능.
- [ ]  스택
    - Last In First Out, 데이터 추가/삭제가 단방향으로만 가능하다. Push-Pop
    - 예) 문자열의 괄호 대응 관계, 깊이 우선 탐색
- [ ]  큐
    - First In First Out, 데이터 추가/삭제가 단방향으로만 가능하다. Enqueue-Dequeue
    - 예) 너비 우선 탐색
- [ ]  해시테이블: 주로 보안 관련 알고리즘에서 많이 쓰이므로 이번 기회에는 pass. 배열 내의 특정 데이터에 빠르게 접근할 수 있다.
- [ ]  힙
    - 그래프의 트리 구조 중 하나: 우선순위 큐의 구현. 언제나 complete binary tree이다.
    - 추가는 자유롭되 추출할 때는 작은 값부터 꺼낸다; 최솟값을 자주 추출해야 하는 경우에 용이. 자식 노드의 숫자가 반드시 부모의 숫자보다 크다.
- [ ]  이진탐색트리
    - 현재 노드의 값은 그 왼쪽 가지의 어떤 값보다 크다. 마찬가지로, 그 오른쪽 가지의 어떤 값보다 작다.
    - 위 규칙에 따라 노드를 추가한다. 삭제할 때는 대상 노드를 삭제하고 왼쪽 가지에서 최대 노드를 찾아서 이동한다.
    - 트리의 높이/깊이/단계만큼 비교하므로 균형 잡힌 트리의 경우 logN회 비교로 이동 가능하다. 트리가 한 쪽으로 치우친 경우 worst O(n)이 될 수도 있다.

# Sort

- [ ]  Bubble/Selection/ Insertion/ Merge/ Quick Sort
- [ ]  Heap Sort

# Search

- [ ]  Linear search
- [ ]  Binary Search

# Graph

정점(Vertex), 간선(Edge) / 가중치(weight) / 방향(direction)

Facebook mutual friends/ 지하철 노선도(with 소요 시간/운임 등)/ 네트워크 라우터 접속 관계

**그래프 탐색**

- [ ]  BFS
    - 후보 추가(큐 사용하여 후보 관리) - 제일 먼저 추가한 후보로 이동 - 탐색 마친 것은 visited 처리 후, 도달할 수 있는 후보 추가 - 제일 먼저 추가한 후보로 이동 - 반복
- [ ]  DFS
    - 후보 추가(스택 사용하여 후보 관리) - 제일 최근에 추가한 후보로 이동 - 탐색 마친 것은 visited 처리 후, 도달할 수 있는 후보 추가 - 제일 최근에 추가한 후보로 이동 - 반복

**최단 경로 문제: 가중치 그래프, 시작점/종점이 주어진다.**

- [ ]  Bellman-Ford
    - 시작점(초기값은 0)에서 간선을 따라가며 다른 정점의 값(초기값은 무한대)을 바꿔나간다. 한 번에 한 정점씩 값을 계산하고 이동한다.  전체 작업이 끝난 시점에는 다른 정점의 값이 바뀌어 있기 때문에 값을 업데이트 하는 전체 작업을 반복 수행한다. 더 변화가 없으면 멈추고 최단 경로를 확인한다.
- [ ]  Dijkstra
    - 벨만 포드와 비슷하나 다익스트라의 경우 최단 경로를 정해 나가며 그래프를 탐색한다. 현재 경로에서 이동할 수 있는 정점을 후보로 추가하고, 후보 정점의 값을 바꾸고, 가장 작은 값을 가지는 정점으로 이동한다.
    - 방향성 그래프의 경우 마이너스 가중치를 포함하는 경우에 올바른 최단 경로를 확인하기 어렵다.
- [ ]  A* : 그래프의 최간 경로를 찾는다. 이 때 시작점에서 각 정점까지의 최단 경로(다익스트라) 뿐만 아니라 현시점에서 목표까지의 추정 가중치(heuristic weight: 사전 정보를 가지고 최적의 추적 가중치를 사람이 미리 설정한다.)도 함께 고려한다.

# Clustering

- ‘비슷한 것’을 묶는 알고리즘: 두 개의 데이터 사이의 거리를 정의한다. / 몇 개의 묶음으로 묶을 것인가?
- [ ]  K-means 알고리즘

# 기타 알고리즘

- [ ]  유클리드: 두 수의 최대공약수를 구하는 알고리즘; mod가 0이 될 때까지!
- [ ]  소수 판별법:
    - 어떤 수가 주어질 때 그 제곱근까지의 모든 숫자를 차례대로 mod 연산한다.
    - 페르마 테스트: ‘어떤 수가 소수일 가능서이 높은지’를 판별. 어떤 소수 p가 주어질 때, p보다 작은 수를 각각 p제곱하여 그 숫자를 mod p한다. 소수일 경우 n^p mod p = n 이 성립한다. 그러나 이 식을 만족하는 합성수가 존재하기 대문에 이를 확률적 소수 판별법이라고 한다.
- [ ]  페이지 랭크
- [ ]  하노이의 탑: **재귀**
